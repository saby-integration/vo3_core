
Функция сбисПрограммыКриптографии() Экспорт
	
    Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ 
					|		Программы.ИмяПрограммы КАК ИмяПрограммы, 
					|		Программы.ТипПрограммы КАК ТипПрограммы, 
					|		ЕстьNULL(Пути.ПутьКПрограмме,"""") КАК ПутьКПрограмме
					|	Из Справочник.ПрограммыЭлектроннойПодписиИШифрования КАК Программы
					|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПутиКПрограммамЭлектроннойПодписиИШифрованияНаСерверахLinux КАК Пути ПО Программы.Ссылка = Пути.Программа
					|		ГДЕ НЕ ПометкаУдаления
					|";
	ОписанияПрограмм = Новый Массив; 
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			СвойстваПрограммы = Новый Структура("ИмяПрограммы,ПутьКПрограмме,ТипПрограммы", Выборка.ИмяПрограммы,Выборка.ПутьКПрограмме,Выборка.ТипПрограммы);
			ОписанияПрограмм.Добавить(СвойстваПрограммы);
		КонецЦикла;
	Исключение
	КонецПопытки;
	Возврат ОписанияПрограмм;
КонецФункции

Функция сбисОпределитьДанныеДляПодписания(context, doc, action) Экспорт
	ДанныеДляПодписания = Новый Структура();
	Если get_prop(action, "ТребуетПодписания")="Да" Тогда
		СертификатыДействия = get_prop(action, "Сертификат");
		Если СертификатыДействия <> Неопределено и СертификатыДействия.Количество() Тогда
			ИмяПродукта = ПолучитьИмяПродукта();	
			ЛокальныеСертификатыНаКлиенте = ХранилищеОбщихНастроек.Загрузить(ИмяПродукта, "КэшЛокальныхСертификатов");
			ЛокальныеСертификатыНаСервере = сбисСписокЛокальныхСертификатовНаСервере();		
			ДанныеДляПодписания = сбисВыбратьПодходящийСертификат(СертификатыДействия, ЛокальныеСертификатыНаСервере, ЛокальныеСертификатыНаКлиенте);
		КонецЕсли;
	КонецЕсли;
	Возврат ДанныеДляПодписания;
КонецФункции

Функция сбисВыбратьПодходящийСертификатНаСервере(ЛокальныеСертификатыНаСервере, СертДок)
	Результат = Новый Структура();
	Для Каждого Серт из ЛокальныеСертификатыНаСервере.Отпечатки Цикл
		СертОтпечаток = СтрЗаменить(Строка(Серт), " ", "");
		Если СертОтпечаток <> СертДок["Отпечаток"] Тогда 
			Продолжить;
		КонецЕсли;	
		НаборАлгоритмов = сбисВыбратьНаборАлгоритмовДляСозданияПодписи(СертДок["Алгоритм"]);
		Для Каждого Алгоритм Из ЛокальныеСертификатыНаСервере.Алгоритмы Цикл
			Если НаборАлгоритмов.Найти(Алгоритм.Ключ) <> Неопределено Тогда
				Результат.Вставить("СертификатДляПодписания", Новый Структура("Отпечаток, Алгоритм", Серт, Алгоритм.Ключ));    
				Результат.Вставить("СертификатДок", СертДок);
				Результат.Вставить("Тип", "ЛокальноеНаСервере");
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Возврат Результат;
КонецФункции  

Функция сбисВыбратьПодходящийСертификатНаКлиенте(ЛокальныеСертификатыНаКлиенте, СертДок)
	Результат = Новый Структура();
	Если ЛокальныеСертификатыНаКлиенте = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;	
	Для Каждого Серт из ЛокальныеСертификатыНаКлиенте.Отпечатки Цикл
		СертОтпечаток = СтрЗаменить(Строка(Серт), " ", "");
		Если СертОтпечаток <> СертДок["Отпечаток"] Тогда   
			Продолжить;
		КонецЕсли;	
		НаборАлгоритмов = сбисВыбратьНаборАлгоритмовДляСозданияПодписи(СертДок["Алгоритм"]);
		Для Каждого Алгоритм Из ЛокальныеСертификатыНаКлиенте.Алгоритмы Цикл
			Если НаборАлгоритмов.Найти(Алгоритм.Ключ) <> Неопределено Тогда
				Результат.Вставить("СертификатДляПодписания", Новый Структура("Отпечаток, Алгоритм", Серт, Алгоритм.Ключ));    
				Результат.Вставить("СертификатДок", СертДок);
				Результат.Вставить("Тип", "ЛокальноеНаКлиенте");
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;	
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция сбисВыбратьПодходящийСертификат(СертификатыДок, ЛокальныеСертификатыНаСервере, ЛокальныеСертификатыНаКлиенте) Экспорт               
	Результат = Новый Структура(); 
	ТипКлючейОтложенное = Новый Массив;
	ТипКлючейОтложенное.Добавить("Отложенный");
	ТипКлючейОтложенное.Добавить("ОтложенныйСПодтверждением");
	ТипКлючейОтложенное.Добавить("Серверный");
	Для Каждого СертДок Из СертификатыДок Цикл 
		ТипКлюча = СертДок["Ключ"]["Тип"];
		Если ТипКлючейОтложенное.Найти(ТипКлюча) <> Неопределено Тогда
			Результат.Вставить("СертификатДляПодписания", Неопределено);
			Результат.Вставить("СертификатДок", СертДок); 
			Результат.Вставить("Тип", "Отложенное");
			Возврат Результат;
		КонецЕсли;	
		Если ТипКлюча = "Клиентский" Тогда
			Результат = сбисВыбратьПодходящийСертификатНаСервере(ЛокальныеСертификатыНаСервере, СертДок);
			Если Результат.Количество() <> 0 Тогда 
				Возврат Результат;
			КонецЕсли;  
			Результат = сбисВыбратьПодходящийСертификатНаКлиенте(ЛокальныеСертификатыНаКлиенте, СертДок); 
			Если Результат.Количество() <> 0 Тогда 
				Возврат Результат;
			КонецЕсли; 
		КонецЕсли;	
		Если ТипКлюча = "Дистанционный" Тогда
			Результат.Вставить("СертификатДляПодписания", Новый Структура("Отпечаток", СертДок["Отпечаток"]));
			Результат.Вставить("СертификатДок", СертДок);
			Результат.Вставить("Тип", "Дистанционное");
			Возврат Результат;
		КонецЕсли;	
		Если ТипКлюча = "ПростаяПодпись" Тогда
			Результат.Вставить("Тип", "Простое");
			Результат.Вставить("СертификатДляПодписания", Истина);
			Результат.Вставить("СертификатДок", СертДок);
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции


// Считывает двоичные данные по ссылке из файлов в документе и добавляет их в реквизит "ДвоичныеДанные"
//
// Параметры:
//  context - Структура - Контекст.
//  doc - Соответствие - данные документа.
//
//DynamicDirective
Процедура ПолучитьДвоичныеДанныеВложений(context, doc) Экспорт
	Вложения = doc["Этап"]["Вложение"];
	Для Каждого Вложение Из Вложения Цикл 
		Файл = get_prop(Вложение, "Файл", Неопределено);
		Если Файл = Неопределено Тогда Продолжить; КонецЕсли;
		Ссылка = get_prop(Файл,"Ссылка",Неопределено); 
		Если Ссылка = Неопределено Тогда Продолжить; КонецЕсли;	
		ДвоичныеДанные = get_prop(Файл,"ДвоичныеДанные",Неопределено);
		Если ДвоичныеДанные = Неопределено Тогда 
			ДвоичныеДанные = ТранспортИнтеграции.local_helper_download_from_link(context.params, Ссылка);
			Файл.Вставить("ДвоичныеДанные", Base64Строка(ДвоичныеДанные));
			Вложение.Вставить("Файл", Файл);
		КонецЕсли;	
	КонецЦикла;
	doc["Этап"]["Вложение"] = Вложения;	
КонецПроцедуры

// Подписывает данные и обновляет вложения
//
// Параметры:
//  context - Структура - Контекст.
//  doc - Соответствие - данные документа.
//  ДанныеДляПодписания - Соответствие - данные для подписания.
//  block_context - Произвольный - контекст исполняемого блока.
//
// Возвращаемое значение:
//   Неопределено
//
//DynamicDirective
Функция get_signatures(context, doc, ДанныеДляПодписания, block_context)
	Если ДанныеДляПодписания["Тип"] = "Дистанционное" Тогда
		ПодписатьДистанционно(context, doc["Этап"]["Вложение"], ДанныеДляПодписания["СертификатДляПодписания"]);
	ИначеЕсли ДанныеДляПодписания["Тип"] = "ЛокальноеНаСервере" Тогда
		ПолучитьДвоичныеДанныеВложений(context, doc);
		ПодписатьНаСервере(context, doc["Этап"]["Вложение"], ДанныеДляПодписания["СертификатДляПодписания"]);
	ИначеЕсли ДанныеДляПодписания["Тип"] = "ЛокальноеНаКлиенте" Тогда
		ПодписатьНаКлиенте(context, doc["Этап"]["Вложение"], ДанныеДляПодписания, block_context);
	ИначеЕсли ДанныеДляПодписания["Тип"] = "Простое" Тогда
		doc["Этап"].Удалить("Вложение");
		Возврат Неопределено;
	КонецЕсли;
	
	// Чистим вложения от лишней информации
	Вложения = Новый Массив;	
	Для каждого _Вложение из doc["Этап"]["Вложение"] Цикл
		ВложениеДанные = Новый Структура("Идентификатор, Подпись", _Вложение["Идентификатор"], _Вложение["Подпись"]);
		Если ДанныеДляПодписания.СертификатДок["Доверенность"] <> Неопределено Тогда
			Для каждого _Подпись из _Вложение["Подпись"] Цикл
				_Подпись.Вставить("Сертификат", Новый Структура("Доверенность", ДанныеДляПодписания.СертификатДок["Доверенность"]));	
			КонецЦикла;	
		КонецЕсли;	
		Вложения.Добавить(ВложениеДанные);		
	КонецЦикла;
	doc["Этап"]["Вложение"] = Вложения;
КонецФункции

